# Day1

# Web RTC(Web Real-Time Communication )


- 화상통화, 화상 공유 등을 구현할 수 있는 오픈 소스
- 비디오, 음성 및 일반 데이터가 P2P 방식으로 피어간의 전송되도록 지원
- JavaScript API로 제공

---

## 장점

### 1. 대기시간(Latency)이 짧다

인스타라이브, 유튜브라이브, 트위치 등은 RTMP(Real Time Messaging Protocol) {실시간 스트리밍 데이터를 불특정 다수들이 받아 볼 수 있도록 하는 기술의 규격)

### 2. 별 다른 소프트웨어 없이 실시간 커뮤니 케이션이 가능하다

### 3. 개발하는 데 있어 진입장벽이 낮다.

### 4. 무료다

---

## 단점

### 1. 크로스 브라우징 문제

Web RTC는 현재 크롬, 오페라, 파이어폭스 뿐만 아니라 안드로이드, IOS 등 브라우저, 앱에서 활용할 수 있다. 

그러나, 사람들이 잘 사용하지 않는 브라우저나 최신 버전을 사용하지 않은 사용자는 사용이 불가능하다는 단점이 있다 (인터넷 익스플로러는 지원되지 않음)

### 2. STUN/TURN 서버 필요

P2P 통신을 하기 위해서는 사용자의 IP 주소를 알아야 한다.

하지만 대부분의 사용자는 방화벽등을 사용하고 다른 네트워크 상에서 연결이 이루어지기 위해서는 STUN/TURN 서버가 꼭 필요하다

---

## 구현시

프론트 : 

- 로컬 미디어 스트림 처리(사용자의 마이크, 카메라 데이터 권한등을 가져오는 것)
- RTCPeerConnection 객체 생성 및 관리 ( RTC 연결 관리 , P2P 통신 연결을 의미)
- 시그널링 메시지 송수신(사용자 간 입장, 퇴장 시 메세지 송수신 의미)
- SDP 생성(offer, answer)
- ICE(interactive connectivity establishment) candidate 생성
- 원격 스트림 표시
- UI 관련 모든 처리

벡엔드 (중계자 역할, 연결 수립을 위한 시그널링만 담당)

- 사용자 세션 관리(
- 룸 생성 및 관리
- 채팅 기능 구현
- 시그널링 서버 구현 및 메세지 중계
- 참가자 상태 관리
- 보안 처리
- 에러 처리 및 로깅

SDP(Session Description protocol) 

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/59aa5595-a299-484d-bee1-12064dce810d/58f6abcf-c435-4e91-9f0d-cd365bf9983c/image.png)

1. 앨리스가 SDP 형태의 offer 메세지를 생성
2. 앨리스가 생성된 offer 메세지를 본인의 로컬디스크립션으로 등록
3. 앨리스가 offer 메세지를 시그널링 서버에게 전달
4. 시그널링 서버는 상대방 밥을 찾아서 SDP 정보를 전달
5. 밥은 전달받은 offer 메시지를 본인의 리모트디스크립션에 등록
6. 밥은 answer 메세지를 생성
7. 생성된 answer 메세지를 본인의 로컬디스크립션으로 등록
8. 밥은 answer 메세지를 시그널링 서버에게 전달
9. 시그널링 서버는 상대방 앨리스를 찾아서 answer 메세지를 전달
10. 앨리스는 전달받은 answer 메시지를 본인의 리모트디스크립션에 등록

SDP를 서로 교환한 후, 각 피어는 서로의 주소값을 알기 위해 ICE Candidate를 교환한다.

이때 사용되는 기술이 NAT Traversal 이다.

각 ICE 메세지들은 두개의 컴퓨터를 서로 연결하기 위한 정보들에 덧붙여 프로토콜(TCP or UDP) , IP주소 , 포트번호, 연결타입 등을 제안한다

---

## 프론트 중심 구현 권장 이유

1. 브라우저 API 접근성
- WebRTC API는 브라우저에 최적화 되어 있음
- 벡엔드에서 구현 시 많은 제약사항 존재(자바에서 WebRTC를 직접 다루는 것은 복잡하고 제한적이다, 외부 라이브러리 필요(webrtc4j, libwebrtc 등) (미디어 디바이스 접근이 복잡하거나 불가능, 외부 라이브러리 의존 필요, os 레벨의 권한 문제 발생)
- 즉, 추가 지연 발생

- 에러 처리 또한 프론트에선 에러를 감지하고 즉각적인 재연결 시도, 즉시 피드백 제공이 가능하지만 벡엔드에선 클라이언트 상태 파악이 어렵고, 실시간 대응이 제한적이다

즉 사용자 경험 저하가 야기됨

- 리소스 관리
    - 프론트에선 리소스 해제가 명확하고 간단(RTCPeerConnection 객체 관리)
    - 백엔드에선 복잡한 리소스 관리 필요(메모리 누수 위험, 가비지 컬렉션 이슈)

- 표준화 및 호환성
    - 프론트엔드는 표준 WebRTC API 사용
    - 벡엔드는 비표준 구현 필요, 브라우저별 호환성 이슈 처리 복잡

1. 성능
- P2P 연결은 프론트엔드 간 직접 이루어지는 것이 효율적
- 벡엔드를 통한 처리는 불필요한 지연 발생

1. 유지보수
- 프론트엔드 중심 구현이 디버깅과 문제 해결이 용이
- 표준 WebRTC API 활용으로 안전성 보장

효율적인 구현 방식은 벡엔드는 시그널링에만 집중 

더불어 룸관리, 세션관리, 채팅기능 , 메시지 중계 에만 집중하는 것이 가장 효율적

<br>

---
<br>

# Day2

<br>

# 프로젝트 기획 학습 내용 정리

## 1. 프로젝트 기획의 기본 개념
오늘 학습한 프로젝트 기획은 성공적인 프로젝트 수행을 위한 첫 단계로, 프로젝트의 목표 설정부터 실행 계획 수립까지의 전반적인 과정을 포함합니다.

## 2. 주요 학습 내용

### 2.1 프로젝트 정의 단계
- 프로젝트의 목적과 범위 설정
- 이해관계자 분석
- 요구사항 수집 및 분석
- 프로젝트 실현 가능성 검토

### 2.2 프로젝트 계획 수립
- WBS(Work Breakdown Structure) 작성
- 일정 계획 수립
- 자원 배분 계획
- 리스크 관리 계획
- 예산 계획 수립

### 2.3 프로젝트 기획 도구
- 간트 차트(Gantt Chart)
- PERT/CPM
- 마인드맵
- 요구사항 정의서
- 프로젝트 계획서

## 3. 핵심 takeaway
1. 철저한 사전 기획이 프로젝트 성공의 핵심
2. 이해관계자와의 원활한 소통 중요성
3. 명확한 목표 설정의 필요성
4. 리스크 관리의 중요성

## 4. 실무 적용 포인트
- 프로젝트 범위 명확화
- 현실적인 일정 수립
- 구체적인 산출물 정의
- 효과적인 자원 배분

## 5. 향후 학습 계획
- 프로젝트 관리 도구 실습
- 실제 케이스 스터디 분석
- 리스크 관리 심화 학습

## 6. 결론
프로젝트 기획은 단순한 계획 수립이 아닌, 프로젝트의 성공을 좌우하는 핵심 과정임을 이해하였습니다. 체계적인 기획 과정을 통해 효율적인 프로젝트 수행이 가능함을 학습하였습니다.

---

<br>

# Day 3

<br>

---

| No | 요구사항ID | 주요기능 | 요구사항명 | 기능설명 | 상세기능 | 필수데이터 | 우선순위 | 핵심기능(Y/N) | 담당자 |
|---|------------|----------|------------|----------|-----------|-------------|-----------|---------------|--------|
| 1 | REQ-101 | 회원 관리 | 회원가입 | 유저가 회원 가입을 한다. | -사용자 정보 : 프로필사진, 아이디, 휴대전화, 이름, 닉네임, 생년월일, 비밀번호, 비밀번호 재확인<br>-UI : 각 정보를 한 페이지에 하나씩 받아 입력창을 크게 만들어 직관화 한다<br>-프로필 사진을 등록하지 않는 경우, 기본 이미지 사용<br>-아이디 중복 확인<br>-SMS 인증<br>-비밀번호 암호화 : 해시알고리즘 + SALT | 프로필사진, 아이디, 휴대전화, 이름, 닉네임, 생년월일, 비밀번호 | 상 | Y | |
| 2 | REQ-102 | | 로그인 | 회원이 로그인을 할 수 있다 | -가입한 정보 기반으로 서버에 세션 정보 등록 후 메인페이지 이동.<br>- 자동로그인 선택 후 로그인 할 경우, 서버에 요청하여 쿠키 생성 후 사용자 브라우저에 저장. | 아이디, 비밀번호, 자동로그인 체크 boolean 값 | 상 | Y | |
| 3 | REQ-103 | | 자동로그인 | 기능을 체크한 회원이라면 로그인 과정 없이 로그인 할 수 있다 | 사용자가 웹페이지에 접속할 때 브라우저에 저장된 쿠키가 있는지 확인.<br>- 있다면 세션에 정보를 등록하고 계정정보를 찾아 로그인처리 후 메인페이지.<br>- 없다면 그냥 메인페이지. | 브라우저 Cookie | 중 | N | |
| 4 | REQ-104 | | 친구 추가 | 번호를 저장해서 친구로 등록할 수 있다 | - 사용자 번호와 이름을 입력받아 사용자의 친구 리스트 DB에 저장. | 이름, 전화번호, 본인 uid | 상 | Y | |
| 5 | REQ-105 | | 친구 삭제 | 등록한 친구를 삭제할 수 있다 | 친구리스트 DB에서 선택한 친구를 삭제한다 | 본인 uid | 상 | Y | |
| 6 | REQ-106 | | 친구 목록 | 등록한 친구들을 확인할 수 있다.<br>친구들의 접속 현황을 확인할 수 있으며 마지막 접속시간을 알 수 있다.<br>친구 목록에서 바로 화상통화를 진행할 수 있다. | -친구리스트 DB에서 데이터를 읽어와 사용자에게 보여준다.<br>-등록된 각 사용자의 접속현황 표시<br>-오프라인이라면 마지막 접속시간 표시<br>-온라인이라면 각 친구마다 바로 화상통화를 걸 수 있어야 한다<br>-사용자가 저장한 이름으로 이름이 표시되어야 한다 | | 상 | Y | |
| 7 | REQ-107 | | 회원 탈퇴 | 회원 탈퇴를 할 수 있다 | -유저 DB에서 회원정보를 삭제한다 | 본인 uid | 하 | N | |
| 8 | REQ-108 | | 로그아웃 | 로그아웃을 할 수 있다 | -사용자의 브라우저에서 쿠키를 삭제하고, 서버의 세션에서도 삭제<br>-메인페이지로 이동한다 | 본인 uid | 중 | Y | |
| 9 | REQ-109 | | 회원정보 수정 | 마이페이지에서 닉네임, 휴대전화, 프로필사진, 비밀번호를 수정할 수 있다 | -DB에서 사용자의 정보를 업데이트한다 | 본인 uid , 바뀔 정보 | 하 | N | |

---

# Day4

---

<br>

# 요구사항 정의서 작성 완료 

https://docs.google.com/spreadsheets/d/15NjezMcbgLvDOQ7qchuUE91fVVffiyigm53yokB_3qw/edit?gid=1371555230#gid=1371555230

<br>

---

# 피그마 기획 작성

![figma](./img/figma.png)



# Day 5

---

<br>

- 유저 테이블
    - uid → pk
    - id → 아이디 or 카카오 이메일
    - password
    - name
    - birth
    - phone
    - logined_at
- 카카오 유저 테이블
    - id → autoIncre pk
    - uid fk
    - oauth_id
    - access_token
    - refresh_token
    - 외래키 cascade
- 보안 테이블
    - uid pk,fk
    - random salt 뭐시기(원래는 물리적으로 다른 곳)
- 친구 테이블
    - id pk
    - uid (본인) fk
    - fid (친구)  fk
    - status (enum)
- 게임 카테고리별 테이블
    - uid pk fk
    - average (double)
    - category (enum)
- 게임 기록 일 별 테이블(해당 월 -30/31일)  → 배치
    - id pk
    - uid fk
    - game_category (enum, ?)
    - score (int)
    - played_at (datetime)
- 게임 결과테이블(1월 - 30점, 2월 - 40점)  → 배치
    - **한 달이 지날 때마다 게임 기록 일 별 테이블을 가져와 해당 월의 평균을 갖고 와서 계산 후 삽입**
    - id pk
    - uid fk
    - date(%Y-%M)
    - score(double)
- 말동무테이블
    - uid pk,fk
    - last_conversation_summary (textarea)
- 사용자 치매진단테이블
    - uid pk,fk
    - user_answer_smcq - json {1 : 1, 2: 1 , ,,,, 14: 0}
    - user_prev_smcq -  json {1 : 1, 2: 1 , ,,,, 14: 0}
    - protector_answer_sdq - json{1 : 1, 2: 0 , ,,,,  32: 1}
    - user_date
    - protector_date