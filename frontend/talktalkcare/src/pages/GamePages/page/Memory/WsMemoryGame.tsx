import React, { useState, useEffect } from 'react';
import './MemoryGame.css';
import GameComplete from '../GameComplete';
import GamePage from '../WsGamePage';
import { sendGameEvent as sendGameEventAPI, GameEvent } from '../../../../services/gameEventService';
import { useWebSocket } from '../../../../contexts/WebSocketContext';

// --- Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Ï†ïÏùò ---
interface Card {
  id: number;
  content: string;
  isFlipped: boolean;
}

interface LevelConfig {
  time: number;
  grid: number;
  emojis: string[];
}

interface Rewards {
  bronze: boolean;
  silver: boolean;
  gold: boolean;
}

interface LevelConfigs {
  [key: number]: LevelConfig;
}

// --- Î†àÎ≤®Î≥Ñ ÏÑ§Ï†ï (Í∏∞Ï°¥Í≥º ÎèôÏùº) ---
const levelConfig: LevelConfigs = {
  1: {
    time: 120,
    grid: 16,
    emojis: ['üçé', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá', 'üçì', 'ü•ù']
  },
  2: {
    time: 90,
    grid: 16,
    emojis: ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº']
  },
  3: {
    time: 60,
    grid: 36,
    emojis: ['‚≠ê', 'üåô', '‚òÄÔ∏è', '‚ö°', 'üåà', '‚òÅÔ∏è', '‚ùÑÔ∏è', 'üå∏', 'üå∫', 'üåª', 'üåπ', 'üçÄ', 'üå¥', 'üåµ', 'üéÑ', 'üå≤', 'üå≥', 'üåæ']
  }
};

const WsMemoryGame: React.FC = () => {
  // --- Î°úÏª¨ ÏÉÅÌÉú (MemoryGameÍ≥º ÎèôÏùº) ---
  const [cards, setCards] = useState<Card[]>([]);
  const [flipped, setFlipped] = useState<number[]>([]);
  const [matched, setMatched] = useState<number[]>([]);
  const [moves, setMoves] = useState<number>(0);
  const [isLocked, setIsLocked] = useState<boolean>(false);
  const [gameStarted, setGameStarted] = useState<boolean>(false);
  const [level, setLevel] = useState<number>(1);
  const [timer, setTimer] = useState<number | null>(null);
  const [rewards, setRewards] = useState<Rewards>({
    bronze: false,
    silver: false,
    gold: false
  });
  const [gameCompleted, setGameCompleted] = useState<boolean>(false);
  const [isForceQuit, setIsForceQuit] = useState<boolean>(false);
  const [completedLevel, setCompletedLevel] = useState<number>(0);
  const [isPreview, setIsPreview] = useState<boolean>(true);
  const [previewTime, setPreviewTime] = useState<number>(10);

  const { onGameSelected } = useWebSocket();

  // --- Ìó¨Ìçº: ÏõπÏÜåÏºì Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ° ---
  const sendEvent = (eventType: string, payload?: any) => {
    const currentUserId = Number(localStorage.getItem('userId'));
    const opponentUserId = Number(localStorage.getItem('opponentUserId'));
    const event: GameEvent = { eventType, senderId: currentUserId, opponentUserId, payload };
    //console.log("Î≥¥ÎÇ¥Îäî Ïù¥Î≤§Ìä∏:", event);
    sendGameEventAPI(event);
  };

  // --- ÏõπÏÜåÏºì Ïù¥Î≤§Ìä∏ ÏàòÏã† (ÏÉÅÎåÄÎ∞©Ïùò Ïï°ÏÖò Î∞òÏòÅ) ---
  useEffect(() => {
    const localUserId = localStorage.getItem('userId');
    onGameSelected((event: GameEvent) => {
      if (event.senderId.toString() === localUserId) return;
      //console.log('ÏÉÅÎåÄÎ∞©ÏúºÎ°úÎ∂ÄÌÑ∞ ÏàòÏã†Ìïú Ïù¥Î≤§Ìä∏:', event);
      switch (event.eventType) {
        case 'MEMORY_INIT':
          if (event.payload) {
            setLevel(event.payload.level);
            setTimer(event.payload.timer);
            setPreviewTime(event.payload.previewTime);
            setCards(event.payload.cards);
            setIsPreview(event.payload.isPreview);
            setGameStarted(true);  // Í≤åÏûÑ ÏãúÏûë ÏÉÅÌÉú ÎèôÍ∏∞Ìôî
          }
          break;
        case 'GAME_STATE_REQUEST':
          // Ïù¥ÎØ∏ Í≤åÏûÑ Ï§ëÏù¥Î©¥ ÌòÑÏû¨ ÏÉÅÌÉúÎ•º ÏùëÎãµ
          if (gameStarted) {
            sendEvent('GAME_STATE_RESPONSE', {
              level,
              timer,
              previewTime,
              cards,
              isPreview,
              gameStarted
            });
          }
          break;
        case 'GAME_STATE_RESPONSE':
          // ÏïÑÏßÅ Í≤åÏûÑ ÏãúÏûë ÏÉÅÌÉúÍ∞Ä ÏïÑÎãàÎùºÎ©¥ ÏóÖÎç∞Ïù¥Ìä∏
          if (!gameStarted && event.payload) {
            setLevel(event.payload.level);
            setTimer(event.payload.timer);
            setPreviewTime(event.payload.previewTime);
            setCards(event.payload.cards);
            setIsPreview(event.payload.isPreview);
            setGameStarted(event.payload.gameStarted);
          }
          break;
        case 'MEMORY_CARD_FLIPPED': {
          const { cardId } = event.payload;
          if (!flipped.includes(cardId) && !matched.includes(cardId)) {
            setFlipped(prev => [...prev, cardId]);
            if (flipped.length === 1) {
              const firstCard = cards[flipped[0]];
              const secondCard = cards[cardId];
              if (firstCard && secondCard && firstCard.content === secondCard.content) {
                setMatched(prev => [...prev, flipped[0], cardId]);
                setFlipped([]);
                if (matched.length + 2 === cards.length) {
                  handleLevelComplete();
                }
              } else {
                setTimeout(() => {
                  setFlipped([]);
                }, 1000);
              }
            }
          }
          break;
        }
        case 'MEMORY_LEVEL_COMPLETE':
          setCompletedLevel(event.payload.level);
          if (event.payload.level < 3) {
            setLevel(event.payload.level + 1);
            setIsPreview(true);
            setPreviewTime(10);
            initializeGame();
          } else {
            setGameCompleted(true);
          }
          break;
        case 'MEMORY_GAME_QUIT':
          setGameStarted(false);
          setGameCompleted(true);
          setIsForceQuit(true);
          setCompletedLevel(event.payload.completedLevel);
          break;
        default:
          break;
      }
    });
  // ÌïÑÏöîÌïú ÏÉÅÌÉúÎÇò Ìï®ÏàòÍ∞Ä Î∞îÎÄî ÎïåÎßàÎã§ ÏóÖÎç∞Ïù¥Ìä∏ (ÏµúÏã† Í∞í Î∞òÏòÅÏùÑ ÏúÑÌï¥ ÌïÑÏöîÌïú ÏùòÏ°¥ÏÑ±ÏùÑ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî)
  }, [flipped, matched, cards, onGameSelected, gameStarted, level, timer, previewTime, isPreview]);

  // --- Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú GAME_STATE_REQUEST Ï†ÑÏÜ° ---
  useEffect(() => {
    if (!gameStarted) {
      sendEvent('GAME_STATE_REQUEST');
    }
    // Îã® Ìïú Î≤àÎßå Ïã§Ìñâ
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // --- ÌÉÄÏù¥Î®∏ (Í≤åÏûÑ ÏßÑÌñâ Ï§ë) ---
  useEffect(() => {
    if (gameStarted && timer !== null && timer > 0) {
      const countdown = setInterval(() => {
        setTimer(prev => {
          if (prev !== null && prev <= 1) {
            clearInterval(countdown);
            handleTimeUp();
            return 0;
          }
          return prev !== null ? prev - 1 : null;
        });
      }, 1000);
      return () => clearInterval(countdown);
    }
  }, [gameStarted, timer]);

  // --- ÌîÑÎ¶¨Î∑∞ ÌÉÄÏù¥Î®∏ ---
  useEffect(() => {
    if (isPreview && previewTime > 0) {
      const previewCountdown = setInterval(() => {
        setPreviewTime(prev => prev - 1);
      }, 1000);
      return () => clearInterval(previewCountdown);
    } else if (isPreview && previewTime === 0) {
      setIsPreview(false);
      // ÌîÑÎ¶¨Î∑∞ Ï¢ÖÎ£å Ïãú Î™®Îì† Ïπ¥ÎìúÎ•º Îí§ÏßëÏùå
      setCards(prev => prev.map(card => ({ ...card, isFlipped: false })));
      setFlipped([]);
    }
  }, [isPreview, previewTime]);

  // --- ÏãúÍ∞Ñ ÌòïÏãù Î≥ÄÌôò (UIÏö©) ---
  const formatTime = (seconds: number): string => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  // --- ÏãúÍ∞Ñ Ï¥àÍ≥º Ï≤òÎ¶¨ ---
  const handleTimeUp = (): void => {
    setGameStarted(false);
    setIsLocked(true);
    if (matched.length !== cards.length) {
      alert(`ÏãúÍ∞ÑÏù¥ Ï¥àÍ≥ºÎêòÏóàÏäµÎãàÎã§! ${level}Îã®Í≥ÑÍπåÏßÄ ÏÑ±Í≥µÌïòÏÖ®ÏäµÎãàÎã§!`);
    }
  };

  // --- Í≤åÏûÑ Ï¥àÍ∏∞Ìôî (Î†àÎ≤® ÏãúÏûë Ïãú) ---
  const initializeGame = (): Card[] => {
    const currentLevel = levelConfig[level];
    const newCards: Card[] = [
      ...currentLevel.emojis.slice(0, currentLevel.grid / 2),
      ...currentLevel.emojis.slice(0, currentLevel.grid / 2)
    ]
      .sort(() => Math.random() - 0.5)
      .map((card, index) => ({
        id: index,
        content: card,
        isFlipped: true // ÌîÑÎ¶¨Î∑∞Î•º ÏúÑÌï¥ Ï≤òÏùåÏóî Î™®Îëê Îí§ÏßëÌûò
      }));
    setCards(newCards);
    setFlipped([]);
    setMatched([]);
    setMoves(0);
    setTimer(currentLevel.time);
    setIsLocked(false);
    return newCards;
  };

  // --- Ïπ¥Îìú ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨ ---
  const handleCardClick = (cardId: number): void => {
    if (isPreview || isLocked) return;
    if (flipped.length === 2 || flipped.includes(cardId) || matched.includes(cardId)) return;
    setFlipped([...flipped, cardId]);
    sendEvent('MEMORY_CARD_FLIPPED', { cardId });
    if (flipped.length === 1) {
      setIsLocked(true);
      setMoves(prev => prev + 1);
      const firstCard = cards[flipped[0]];
      const secondCard = cards[cardId];
      if (firstCard.content === secondCard.content) {
        setMatched([...matched, flipped[0], cardId]);
        setFlipped([]);
        setIsLocked(false);
        if (matched.length + 2 === cards.length) {
          handleLevelComplete();
        }
      } else {
        setTimeout(() => {
          setFlipped([]);
          setIsLocked(false);
        }, 1000);
      }
    }
  };

  // --- Î†àÎ≤® ÏôÑÎ£å Ï≤òÎ¶¨ ---
  const handleLevelComplete = (): void => {
    setCompletedLevel(level);
    sendEvent('MEMORY_LEVEL_COMPLETE', { level, moves });
    if (level < 3) {
      setTimeout(() => {
        setLevel(prev => prev + 1);
        setIsPreview(true);
        setPreviewTime(10);
        initializeGame();
      }, 1500);
    } else {
      setGameCompleted(true);
    }
  };

  // --- Í≤åÏûÑ Ïû¨ÏãúÏûë Î∞è Ï¢ÖÎ£å ---
  const handleRestart = (): void => {
    setGameStarted(false);
    setCards([]);
    setFlipped([]);
    setMatched([]);
    setMoves(0);
    setTimer(levelConfig[1].time);
    setLevel(1);
    setCompletedLevel(0);
    setRewards({ bronze: false, silver: false, gold: false });
    setGameCompleted(false);
    setIsForceQuit(false);
  };

  const handleQuit = (): void => {
    setGameStarted(false);
    setGameCompleted(true);
    setIsForceQuit(true);
    setCompletedLevel(level - 1);
    sendEvent('MEMORY_GAME_QUIT', { completedLevel: level - 1 });
  };

  // --- Í≤åÏûÑ ÏãúÏûë (ÌîÑÎ¶¨Î∑∞ Ìè¨Ìï®) ---
  const startGame = (): void => {
    setGameStarted(true);
    setIsPreview(true);
    setPreviewTime(10);
    const newCards = initializeGame();
    sendEvent('MEMORY_INIT', {
      level,
      timer: levelConfig[level].time,
      previewTime: 10,
      cards: newCards,
      isPreview: true
    });
  };

  return (
    <GamePage 
      title="Ïπ¥Îìú Ïßù ÎßûÏ∂îÍ∏∞" 
      timeLimit={levelConfig[level].time}
      onRestart={handleRestart}
      gameStarted={gameStarted}
    >
      <div className="memory-game">
        {!gameStarted ? (
          <div className="instructions">
            <h3 className='instructions-title'>Í≤åÏûÑ Î∞©Î≤ï</h3>
            <p className='instructions-content'>
              1. Ï≤òÏùå 10Ï¥à ÎèôÏïà Î™®Îì† Ïπ¥ÎìúÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.
              <br />
              2. Ïπ¥ÎìúÍ∞Ä Îí§ÏßëÌûàÎ©¥ ÏßùÏùÑ ÎßûÏ∂∞Ï£ºÏÑ∏Ïöî.
              <br />
              3. ÏµúÎåÄÌïú Ï†ÅÏùÄ ÌöüÏàòÎ°ú Î™®Îì† Ïπ¥ÎìúÏùò ÏßùÏùÑ Ï∞æÏúºÏÑ∏Ïöî!
            </p>
            <button onClick={startGame} className='instructions-button'>Í≤åÏûÑ ÏãúÏûë</button>
          </div>
        ) : (
          <div className="game-board">
            {isPreview && (
              <div className="preview-message">
                {previewTime}Ï¥à ÎèôÏïà Ïπ¥ÎìúÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî!
              </div>
            )}
            <div className={`card-grid level-${level}`}>
              {cards.map((card) => {
                const isCardShown = 
                  (isPreview && card.isFlipped) ||
                  (!isPreview && (flipped.includes(card.id) || matched.includes(card.id)));
                return (
                  <div
                    key={card.id}
                    className={`card ${isCardShown ? 'flipped' : ''}`}
                    onClick={() => !isPreview && handleCardClick(card.id)}
                  >
                    <div className="card-inner">
                      <div className="card-front">‚ùî</div>
                      <div className="card-back">{card.content}</div>
                    </div>
                  </div>
                );
              })}
            </div>
            {matched.length === cards.length && cards.length > 0 && (
              <div className="win-message">
                <h2>Ï∂ïÌïòÌï©ÎãàÎã§! {level}Îã®Í≥ÑÎ•º ÌÅ¥Î¶¨Ïñ¥ÌïòÏÖ®ÏäµÎãàÎã§!</h2>
                <p>Ï¥ù {moves}Î≤à ÏãúÎèÑÌïòÏÖ®ÏäµÎãàÎã§.</p>
              </div>
            )}
          </div>
        )}
      </div>
    </GamePage>
  );
};

export default WsMemoryGame;
